{

 "cells": [

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "# Model Quantization Tips\n",

    "\n",

    "This tutorial provides several tips for how to better quantize your model.\n",

    "\n",

    "Model quantization uses the [TfliteConverter](https://www.tensorflow.org/lite/models/convert) to convert a model with **float32** tensors into a model with **int8** tensors. A model with **int8** tensors typically reduces the memory requirements by 4x and also allows for better [hardware acceleration](https://docs.silabs.com/gecko-platform/4.2/machine-learning/tensorflow/mvp-accelerator).\n",

    "\n",

    "While model quantization can greatly reduce memory and computational overhead, it can also reduce model accuracy. This is because converting from __float32__ (32-bits) to __int8__ (8-bits) looses information. So, for quantization to be effective, it must accurately represent the original 32-bit data in 8-bits as efficiently as possible. While the [TfliteConverter](https://www.tensorflow.org/lite/models/convert) does most of the work for you, the following provides some tips on how you can help the model quantize even better."

   ]

  },

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "## Contents\n",

    "\n",

    "This tutorial is divided into the following sections:\n",

    "\n",

    "1. [Quantization Report](#quantization-report) - Describes how to use the MLTK to generate a quantization report to aid with debugging quantization errors\n",

    "2. [Input Data Normalization](#input-data-normalization) - Describes how to normalize the input data so that it can be better quantized\n",

    "3. [Normalization Layers](#normalization-layers) - Describes some of the ML layers that allow for better model quantization"

   ]

  },

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "## Quantization Report\n",

    "\n",

    "Tensorflow-Lite comes with an experimental [Quantization Debugger](https://www.tensorflow.org/lite/performance/quantization_debugger):\n",

    "\n",

    "> Although full-integer quantization provides improved model size and latency, the quantized model won't always work as expected. It's usually expected for the model quality (e.g. accuracy, mAP, WER) to be slightly lower than the original float model. However, there are cases where the model quality can go below your expectation or generated completely wrong results.\n",

    ">\n",

    "> When this problem happens, it's tricky and painful to spot the root cause of the quantization error, and it's even more difficult to fix the quantization error. To assist this model inspection process, quantization debugger can be used to identify problematic layers, and selective quantization can leave those problematic layers in float so that the model accuracy can be recovered at the cost of reduced benefit from quantization.\n",

    ">\n",

    "> Quantization debugger makes it possible to do quantization quality metric analysis in the existing model. Quantization debugger can automate processes for running model with a debug dataset, and collecting quantization quality metrics for each tensors.\n",

    "\n",

    "### Enabling the Quantization Report\n",

    "\n",

    "The MLTK will automatically generate a quantization report during [model quantization](https://siliconlabs.github.io/mltk/docs/guides/model_quantization.html) by setting the [tflite_converter](https://siliconlabs.github.io/mltk/docs/python_api/mltk_model/train_mixin.html#mltk.core.TrainMixin.tflite_converter) setting:\n",

    "\n",

    "```\n",

    "my_model.tflite_converter['generate_quantization_report'] = True\n",

    "```\n",

    "\n",

    "The quantization report is a standard `.csv` file and is added to the [Model Archive](../../docs/guides/model_archive.md) file (it is also generated in the same directory as the `.tflite`, typically `~/.mtlk/models/<model name>/quantization_report.csv`).\n",

    "\n",

    "### Analyzing the Report\n",

    "\n",

    "For each row in the report, the op name and index comes first, followed by quantization parameters and error metrics.\n",

    "\n",

    "Additionally, per the [Data Analysis](https://www.tensorflow.org/lite/performance/quantization_debugger#step_3_data_analysis) section, two additional metrics are calculated:\n",

    "\n",

    "- **Range** - `scale * 255.0`, this provides the range of input values that the given layer should accept. Ideally, this value should be less than 255. Larger values could cause quantization problems at runtime. (Recall that the quantized values must fit within an `int8` data type)\n",

    "- **RMSE / scale** - `sqrt(mean_squared_error) / scale`, this value is close to `1 / sqrt(12)` (~ 0.289) when quantized distribution is similar to the original float distribution, indicating a good quantized model. The larger the value is, the more likely the layer is not being quantized well.\n",

    "\n",

    "So, when viewing a quantization report, if a layer has large values in the `range` and/or `rmse/scale` columns then it could be that the model is not quantizing well. Refer to the next sections for how to fix these issues."

   ]

  },

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "## Input Data Normalization\n",

    "\n",

    "For the best quantization, the range of input values should be evenly distributed around -1.0 to 1.0. While this is not a hard rule, in practice is was found that `rmse/scale` has a lower value when the input values are within this range.\n",

    "\n",

    "The following are methods to normalize the input data:"

   ]

  },

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "### Scale by a constant\n",

    "\n",

    "Scaling by a constant is a computationally efficient method for data normalization:\n",

    "\n",

    "```\n",

    "normalized_input_sample = input_sample / <scaler>\n",

    "```\n",

    "\n",

    "In the training Python scripts, the following may be used:\n",

    "\n",

    "```python\n",

    "# -----------------------------------------\n",

    "# Define the input scaling value\n",

    "# This value should be near the upper limit of the input data\n",

    "input_scaling_value = 255.0\n",

    "\n",

    "# -----------------------------------------\n",

    "# Add the scaling value to the model parameters.\n",

    "# This allows the embedded device to access the scaling value at runtime\n",

    "# Note, we save the scaler *reciprocal*, as multiplication is a more efficient op than division on embedded\n",

    "my_model.model_parameters['samplewise_norm.rescale'] = 1.0 / input_scaling_value\n",

    "\n",

    "# -----------------------------------------\n",

    "# Ensure the input/output data types of the quantized model are float32\n",

    "my_model.tflite_converter['inference_input_type'] = np.float32\n",

    "my_model.tflite_converter['inference_output_type'] = np.float32\n",

    "# Generate a quantization report to help with debugging quantization errors\n",

    "my_model.tflite_converter['generate_quantization_report'] = True\n",

    "\n",

    "\n",

    "# -----------------------------------------\n",

    "# Later, in the training data pipeline, convert the data to float32 and scale the input data\n",

    "x = x.astype(np.float32)\n",

    "x /= input_scaling_value\n",

    "```\n",

    "\n",

    "At runtime on the embedded device, the input data must also be converted to float32 and scaled.\n",

    "The following may be used:\n",

    "\n",

    "```c++\n",

    "\n",

    "#include \"tflite_micro_model/tflite_micro_model.hpp\"\n",

    "\n",

    "using namespace mltk;\n",

    "\n",

    "// Assume the source input data is in uint16 format\n",

    "extern uint16_t *source_input_data;\n",

    "// This is defined by the build scripts\n",

    "// which converts the specified .tflite to a C array\n",

    "extern \"C\" const uint8_t sl_tflite_model_array[];\n",

    "\n",

    "\n",

    "void main()\n",

    "{\n",

    "    TfliteMicroModel model;\n",

    "\n",

    "    // Load the quantized .tflite model\n",

    "    model.load(sl_tflite_model_array);\n",

    "\n",

    "    // Retrieve the input scaler from the .tflite\n",

    "    float input_scaler;\n",

    "    model.parameters.get(\"samplewise_norm.rescale\", input_scaler);\n",

    "\n",

    "    // Obtain a pointer to the input tensor which is in float32 format\n",

    "    TfliteTensorView *input = model.inputs();\n",

    "\n",

    "    // Scale the input data\n",

    "    for(int i = 0; i < input->shape().flat_size(); ++i)\n",

    "    {\n",

    "        input->data.f[i] = (float)source_input_data[i] * input_scaler;\n",

    "    }\n",

    "\n",

    "    // Run inference on the scaled input data\n",

    "    model.invoke();\n",

    "\n",

    "    // Do something with the results\n",

    "    TfliteTensorView results = model.output();\n",

    "}\n",

    "\n",

    "```"

   ]

  },

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "### Center about mean and scale by STD\n",

    "\n",

    "A more robust normalization method is to center the data about the mean and scale by the standard deviation:\n",

    "\n",

    "```\n",

    "normalized_input_sample = (input_sample - mean(input_sample)) / std(input_sample)\n",

    "```\n",

    "\n",

    "In the training Python scripts, the following may be used:\n",

    "\n",

    "```python\n",

    "# -----------------------------------------\n",

    "# This tells the embedded device to normalized by the mean and STD\n",

    "my_model.model_parameters['samplewise_norm.mean_and_std'] = True\n",

    "\n",

    "# -----------------------------------------\n",

    "# Ensure the input/output data types of the quantized model are float32\n",

    "my_model.tflite_converter['inference_input_type'] = np.float32\n",

    "my_model.tflite_converter['inference_output_type'] = np.float32\n",

    "# Generate a quantization report to help with debugging quantization errors\n",

    "my_model.tflite_converter['generate_quantization_report'] = True\n",

    "\n",

    "\n",

    "# -----------------------------------------\n",

    "# Later, in the training data pipeline, convert the data to float32 and normalize\n",

    "x = x.astype(np.float32)\n",

    "x -= np.mean(x, dtype=np.float32, keepdims=True)\n",

    "x /= (np.std(x, dtype=np.float32, keepdims=True) + 1e-6)\n",

    "\n",

    "```\n",

    "\n",

    "At runtime on the embedded device, the input data must also be converted to float32 and normalized.\n",

    "The following may be used:\n",

    "\n",

    "```c++\n",

    "\n",

    "#include \"tflite_micro_model/tflite_micro_model.hpp\"\n",

    "#include \"tflite_micro_model/tflite_micro_utils.hpp\"\n",

    "\n",

    "using namespace mltk;\n",

    "\n",

    "// Assume the source input data is in uint16 format\n",

    "extern uint16_t *source_input_data;\n",

    "// This is defined by the build scripts\n",

    "// which converts the specified .tflite to a C array\n",

    "extern \"C\" const uint8_t sl_tflite_model_array[];\n",

    "\n",

    "\n",

    "void main()\n",

    "{\n",

    "    TfliteMicroModel model;\n",

    "\n",

    "    // Load the quantized .tflite model\n",

    "    model.load(sl_tflite_model_array);\n",

    "\n",

    "    // Retrieve the input scaler from the .tflite\n",

    "    bool mean_and_std_enabled;\n",

    "    model.parameters.get(\"samplewise_norm.mean_and_std\", mean_and_std_enabled);\n",

    "\n",

    "    // Obtain a pointer to the input tensor which is in float32 format\n",

    "    TfliteTensorView *input = model.inputs();\n",

    "\n",

    "    // Use the helper function to normalize the input buffer\n",

    "    samplewise_mean_std_tensor(source_input_data, input->data.f, input->shape().flat_size());\n",

    "\n",

    "    // Run inference on the scaled input data\n",

    "    model.invoke();\n",

    "\n",

    "    // Do something with the results\n",

    "    TfliteTensorView results = model.output();\n",

    "}\n",

    "\n",

    "```"

   ]

  },

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "## Normalization Layers\n",

    "\n",

    "For the best quantization, we want the input data to be evenly distributed around 0.0. The same is true for the inputs to each of the layers of the model.\n",

    "\n",

    "To help with this, [Tensorflow](https://www.tensorflow.org/api_docs/python/tf/keras/layers) / [Keras](https://keras.io/api/layers/#normalization-layers) offer several layers that will normalize the outputs of the preceding layers:"

   ]

  },

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "### Batch Normalization\n",

    "\n",

    "The [Batch Normalization](https://keras.io/api/layers/normalization_layers/batch_normalization/) applies a transformation that maintains the mean output close to 0 and the output standard deviation close to 1.\n",

    "\n",

    "This layer is commonly used in many model architectures. Additionally, if used properly, it can be fused with other layers so that there is minimal runtime overhead.\n",

    "\n",

    "The following are some examples of how to use the [Batch Normalization](https://keras.io/api/layers/normalization_layers/batch_normalization/) layer so that it fused with other layers. In this way:\n",

    "1. The input to the following layer is centered about 0\n",

    "2. The qunatized layer is fused and introduces minimal runtime overhead on the embedded device\n",

    "\n",

    "__NOTE:__ The key for BatchNorm fusion is to invoke the activation _after_ the BatchNorm layer.\n",

    "\n",

    "#### Conv2D + Batch Normalization\n",

    "\n",

    "The following provides an example of how to use batch normalization with a Conv2D layer:\n",

    "\n",

    "```python\n",

    "\n",

    "# Define the Conv2D layer *without* an activation\n",

    "x = tf.keras.layers.Conv2D(\n",

    "    filters=32,\n",

    "    kernel_size=(3, 3),\n",

    "    strides=1,\n",

    ")(x)\n",

    "\n",

    "# Apply batch normalization\n",

    "x = tf.keras.layers.BatchNormalization()(x)\n",

    "\n",

    "# Apply the ReLU activation *after* the batch norm\n",

    "x = tf.keras.layers.ReLU()(x)\n",

    "```\n",

    "\n",

    "#### Fully Connected + Batch Normalization\n",

    "\n",

    "The following provides an example of how to use batch normalization with a Dense (aka Fully Connected) layer:\n",

    "\n",

    "```python\n",

    "\n",

    "# Define the Dense layer *without* an activation\n",

    "x = tf.keras.layers.Dense(10)(x)\n",

    "\n",

    "# Apply batch normalization\n",

    "x = tf.keras.layers.BatchNormalization()(x)\n",

    "\n",

    "# Apply the ReLU activation *after* the batch norm\n",

    "x = tf.keras.layers.ReLU()(x)\n",

    "```"

   ]

  },

  {

   "cell_type": "markdown",

   "metadata": {},

   "source": [

    "### LayerNormalization\n",

    "\n",

    "[LayerNormalization](https://keras.io/api/layers/normalization_layers/layer_normalization/) normalizes the activations of the previous layer for each given example in a batch independently, rather than across a batch like Batch Normalization. i.e. applies a transformation that maintains the mean activation within each example close to 0 and the activation standard deviation close to 1.\n",

    "\n",

    "While this layer introduces more overhead than [Batch Normalization](https://keras.io/api/layers/normalization_layers/batch_normalization/), it is applied on a per-sample basis (as opposed to a per-batch like BatchNorm) which is useful for models that maintain a memory (e.g. recurrent networks).\n",

    "\n",

    "This layer should be applied _before_ the activation, e.g.:\n",

    "\n",

    "```python\n",

    "x = tf.keras.layers.Dense(model.n_classes)(x)\n",

    "x = tf.keras.layers.LayerNormalization()(x)\n",

    "x = tf.keras.layers.Softmax()(x)\n",

    "```"

   ]

  }

 ],

 "metadata": {

  "language_info": {

   "name": "python"

  },

  "orig_nbformat": 4

 },

 "nbformat": 4,

 "nbformat_minor": 2

}

