// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DICTIONARY_H_
#define FLATBUFFERS_GENERATED_DICTIONARY_H_

#include "flatbuffers/flatbuffers.h"


namespace mltk {
namespace schema {


// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

struct BoolValue;
struct BoolValueBuilder;

struct Int8Value;
struct Int8ValueBuilder;

struct Uint8Value;
struct Uint8ValueBuilder;

struct Int16Value;
struct Int16ValueBuilder;

struct Uint16Value;
struct Uint16ValueBuilder;

struct Int32Value;
struct Int32ValueBuilder;

struct Uint32Value;
struct Uint32ValueBuilder;

struct Int64Value;
struct Int64ValueBuilder;

struct Uint64Value;
struct Uint64ValueBuilder;

struct FloatValue;
struct FloatValueBuilder;

struct DoubleValue;
struct DoubleValueBuilder;

struct BinaryValue;
struct BinaryValueBuilder;

struct StringValue;
struct StringValueBuilder;

struct StringList;
struct StringListBuilder;

struct Int32List;
struct Int32ListBuilder;

struct FloatList;
struct FloatListBuilder;

struct Entry;
struct EntryBuilder;

struct Dictionary;
struct DictionaryBuilder;

enum class Value : uint8_t {
  NONE = 0,
  boolean = 1,
  i8 = 2,
  u8 = 3,
  i16 = 4,
  u16 = 5,
  i32 = 6,
  u32 = 7,
  i64 = 8,
  u64 = 9,
  f32 = 10,
  f64 = 11,
  str = 12,
  str_list = 13,
  int32_list = 14,
  float_list = 15,
  bin = 16,
  MIN = NONE,
  MAX = bin
};

inline const Value (&EnumValuesValue())[17] {
  static const Value values[] = {
    Value::NONE,
    Value::boolean,
    Value::i8,
    Value::u8,
    Value::i16,
    Value::u16,
    Value::i32,
    Value::u32,
    Value::i64,
    Value::u64,
    Value::f32,
    Value::f64,
    Value::str,
    Value::str_list,
    Value::int32_list,
    Value::float_list,
    Value::bin
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[18] = {
    "NONE",
    "boolean",
    "i8",
    "u8",
    "i16",
    "u16",
    "i32",
    "u32",
    "i64",
    "u64",
    "f32",
    "f64",
    "str",
    "str_list",
    "int32_list",
    "float_list",
    "bin",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (flatbuffers::IsOutRange(e, Value::NONE, Value::bin)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value::NONE;
};

template<> struct ValueTraits<BoolValue> {
  static const Value enum_value = Value::boolean;
};

template<> struct ValueTraits<Int8Value> {
  static const Value enum_value = Value::i8;
};

template<> struct ValueTraits<Uint8Value> {
  static const Value enum_value = Value::u8;
};

template<> struct ValueTraits<Int16Value> {
  static const Value enum_value = Value::i16;
};

template<> struct ValueTraits<Uint16Value> {
  static const Value enum_value = Value::u16;
};

template<> struct ValueTraits<Int32Value> {
  static const Value enum_value = Value::i32;
};

template<> struct ValueTraits<Uint32Value> {
  static const Value enum_value = Value::u32;
};

template<> struct ValueTraits<Int64Value> {
  static const Value enum_value = Value::i64;
};

template<> struct ValueTraits<Uint64Value> {
  static const Value enum_value = Value::u64;
};

template<> struct ValueTraits<FloatValue> {
  static const Value enum_value = Value::f32;
};

template<> struct ValueTraits<DoubleValue> {
  static const Value enum_value = Value::f64;
};

template<> struct ValueTraits<StringValue> {
  static const Value enum_value = Value::str;
};

template<> struct ValueTraits<StringList> {
  static const Value enum_value = Value::str_list;
};

template<> struct ValueTraits<Int32List> {
  static const Value enum_value = Value::int32_list;
};

template<> struct ValueTraits<FloatList> {
  static const Value enum_value = Value::float_list;
};

template<> struct ValueTraits<BinaryValue> {
  static const Value enum_value = Value::bin;
};

bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Value> *types);

struct BoolValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoolValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BoolValueBuilder {
  typedef BoolValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BoolValue::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BoolValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BoolValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoolValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoolValue> CreateBoolValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BoolValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int8Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int8ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct Int8ValueBuilder {
  typedef Int8Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(Int8Value::VT_VALUE, value, 0);
  }
  explicit Int8ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int8Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int8Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int8Value> CreateInt8Value(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  Int8ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Uint8Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Uint8ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct Uint8ValueBuilder {
  typedef Uint8Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(Uint8Value::VT_VALUE, value, 0);
  }
  explicit Uint8ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Uint8Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint8Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint8Value> CreateUint8Value(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  Uint8ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int16Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int16ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
};

struct Int16ValueBuilder {
  typedef Int16Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(Int16Value::VT_VALUE, value, 0);
  }
  explicit Int16ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int16Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int16Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int16Value> CreateInt16Value(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  Int16ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Uint16Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Uint16ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
};

struct Uint16ValueBuilder {
  typedef Uint16Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(Uint16Value::VT_VALUE, value, 0);
  }
  explicit Uint16ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Uint16Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint16Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint16Value> CreateUint16Value(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  Uint16ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int32Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int32ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct Int32ValueBuilder {
  typedef Int32Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int32Value::VT_VALUE, value, 0);
  }
  explicit Int32ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int32Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int32Value> CreateInt32Value(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  Int32ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Uint32Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Uint32ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct Uint32ValueBuilder {
  typedef Uint32Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(Uint32Value::VT_VALUE, value, 0);
  }
  explicit Uint32ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Uint32Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint32Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint32Value> CreateUint32Value(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  Uint32ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int64Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int64ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct Int64ValueBuilder {
  typedef Int64Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(Int64Value::VT_VALUE, value, 0);
  }
  explicit Int64ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int64Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int64Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int64Value> CreateInt64Value(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  Int64ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Uint64Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Uint64ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct Uint64ValueBuilder {
  typedef Uint64Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(Uint64Value::VT_VALUE, value, 0);
  }
  explicit Uint64ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Uint64Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint64Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint64Value> CreateUint64Value(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  Uint64ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct FloatValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct FloatValueBuilder {
  typedef FloatValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(FloatValue::VT_VALUE, value, 0.0f);
  }
  explicit FloatValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloatValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatValue> CreateFloatValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  FloatValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DoubleValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct DoubleValueBuilder {
  typedef DoubleValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(DoubleValue::VT_VALUE, value, 0.0);
  }
  explicit DoubleValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DoubleValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleValue> CreateDoubleValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct BinaryValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct BinaryValueBuilder {
  typedef BinaryValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(BinaryValue::VT_DATA, data);
  }
  explicit BinaryValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BinaryValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryValue> CreateBinaryValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BinaryValueBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<BinaryValue> CreateBinaryValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateBinaryValue(
      _fbb,
      data__);
}

struct StringValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct StringValueBuilder {
  typedef StringValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(StringValue::VT_DATA, data);
  }
  explicit StringValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringValue> CreateStringValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  StringValueBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringValue> CreateStringValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return CreateStringValue(
      _fbb,
      data__);
}

struct StringList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfStrings(data()) &&
           verifier.EndTable();
  }
};

struct StringListBuilder {
  typedef StringList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data) {
    fbb_.AddOffset(StringList::VT_DATA, data);
  }
  explicit StringListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringList>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringList> CreateStringList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data = 0) {
  StringListBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringList> CreateStringListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*data) : 0;
  return CreateStringList(
      _fbb,
      data__);
}

struct Int32List FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int32ListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct Int32ListBuilder {
  typedef Int32List Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(Int32List::VT_DATA, data);
  }
  explicit Int32ListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Int32List> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32List>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int32List> CreateInt32List(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> data = 0) {
  Int32ListBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int32List> CreateInt32ListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return CreateInt32List(
      _fbb,
      data__);
}

struct FloatList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct FloatListBuilder {
  typedef FloatList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(FloatList::VT_DATA, data);
  }
  explicit FloatListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloatList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatList>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatList> CreateFloatList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  FloatListBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<FloatList> CreateFloatListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return CreateFloatList(
      _fbb,
      data__);
}

struct Entry : private flatbuffers::Table {  typedef EntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  Value value_type() const {
    return static_cast<Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const BoolValue *value_as_boolean() const {
    return value_type() == Value::boolean ? static_cast<const BoolValue *>(value()) : nullptr;
  }
  const Int8Value *value_as_i8() const {
    return value_type() == Value::i8 ? static_cast<const Int8Value *>(value()) : nullptr;
  }
  const Uint8Value *value_as_u8() const {
    return value_type() == Value::u8 ? static_cast<const Uint8Value *>(value()) : nullptr;
  }
  const Int16Value *value_as_i16() const {
    return value_type() == Value::i16 ? static_cast<const Int16Value *>(value()) : nullptr;
  }
  const Uint16Value *value_as_u16() const {
    return value_type() == Value::u16 ? static_cast<const Uint16Value *>(value()) : nullptr;
  }
  const Int32Value *value_as_i32() const {
    return value_type() == Value::i32 ? static_cast<const Int32Value *>(value()) : nullptr;
  }
  const Uint32Value *value_as_u32() const {
    return value_type() == Value::u32 ? static_cast<const Uint32Value *>(value()) : nullptr;
  }
  const Int64Value *value_as_i64() const {
    return value_type() == Value::i64 ? static_cast<const Int64Value *>(value()) : nullptr;
  }
  const Uint64Value *value_as_u64() const {
    return value_type() == Value::u64 ? static_cast<const Uint64Value *>(value()) : nullptr;
  }
  const FloatValue *value_as_f32() const {
    return value_type() == Value::f32 ? static_cast<const FloatValue *>(value()) : nullptr;
  }
  const DoubleValue *value_as_f64() const {
    return value_type() == Value::f64 ? static_cast<const DoubleValue *>(value()) : nullptr;
  }
  const StringValue *value_as_str() const {
    return value_type() == Value::str ? static_cast<const StringValue *>(value()) : nullptr;
  }
  const StringList *value_as_str_list() const {
    return value_type() == Value::str_list ? static_cast<const StringList *>(value()) : nullptr;
  }
  const Int32List *value_as_int32_list() const {
    return value_type() == Value::int32_list ? static_cast<const Int32List *>(value()) : nullptr;
  }
  const FloatList *value_as_float_list() const {
    return value_type() == Value::float_list ? static_cast<const FloatList *>(value()) : nullptr;
  }
  const BinaryValue *value_as_bin() const {
    return value_type() == Value::bin ? static_cast<const BinaryValue *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const BoolValue *Entry::value_as<BoolValue>() const {
  return value_as_boolean();
}

template<> inline const Int8Value *Entry::value_as<Int8Value>() const {
  return value_as_i8();
}

template<> inline const Uint8Value *Entry::value_as<Uint8Value>() const {
  return value_as_u8();
}

template<> inline const Int16Value *Entry::value_as<Int16Value>() const {
  return value_as_i16();
}

template<> inline const Uint16Value *Entry::value_as<Uint16Value>() const {
  return value_as_u16();
}

template<> inline const Int32Value *Entry::value_as<Int32Value>() const {
  return value_as_i32();
}

template<> inline const Uint32Value *Entry::value_as<Uint32Value>() const {
  return value_as_u32();
}

template<> inline const Int64Value *Entry::value_as<Int64Value>() const {
  return value_as_i64();
}

template<> inline const Uint64Value *Entry::value_as<Uint64Value>() const {
  return value_as_u64();
}

template<> inline const FloatValue *Entry::value_as<FloatValue>() const {
  return value_as_f32();
}

template<> inline const DoubleValue *Entry::value_as<DoubleValue>() const {
  return value_as_f64();
}

template<> inline const StringValue *Entry::value_as<StringValue>() const {
  return value_as_str();
}

template<> inline const StringList *Entry::value_as<StringList>() const {
  return value_as_str_list();
}

template<> inline const Int32List *Entry::value_as<Int32List>() const {
  return value_as_int32_list();
}

template<> inline const FloatList *Entry::value_as<FloatList>() const {
  return value_as_float_list();
}

template<> inline const BinaryValue *Entry::value_as<BinaryValue>() const {
  return value_as_bin();
}

struct EntryBuilder {
  typedef Entry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Entry::VT_KEY, key);
  }
  void add_value_type(Value value_type) {
    fbb_.AddElement<uint8_t>(Entry::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Entry::VT_VALUE, value);
  }
  explicit EntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Entry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entry>(end);
    return o;
  }
};

inline flatbuffers::Offset<Entry> CreateEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    Value value_type = Value::NONE,
    flatbuffers::Offset<void> value = 0) {
  EntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entry> CreateEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    Value value_type = Value::NONE,
    flatbuffers::Offset<void> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return CreateEntry(
      _fbb,
      key__,
      value_type,
      value);
}

struct Dictionary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DictionaryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEMA_VERSION = 4,
    VT_ENTRIES = 6
  };
  uint8_t schema_version() const {
    return GetField<uint8_t>(VT_SCHEMA_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entry>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entry>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SCHEMA_VERSION, 1) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct DictionaryBuilder {
  typedef Dictionary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_schema_version(uint8_t schema_version) {
    fbb_.AddElement<uint8_t>(Dictionary::VT_SCHEMA_VERSION, schema_version, 0);
  }
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entry>>> entries) {
    fbb_.AddOffset(Dictionary::VT_ENTRIES, entries);
  }
  explicit DictionaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Dictionary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dictionary>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dictionary> CreateDictionary(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t schema_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entry>>> entries = 0) {
  DictionaryBuilder builder_(_fbb);
  builder_.add_entries(entries);
  builder_.add_schema_version(schema_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Dictionary> CreateDictionaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t schema_version = 0,
    const std::vector<flatbuffers::Offset<Entry>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVector<flatbuffers::Offset<Entry>>(*entries) : 0;
  return CreateDictionary(
      _fbb,
      schema_version,
      entries__);
}

inline bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value::NONE: {
      return true;
    }
    case Value::boolean: {
      auto ptr = reinterpret_cast<const BoolValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::i8: {
      auto ptr = reinterpret_cast<const Int8Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::u8: {
      auto ptr = reinterpret_cast<const Uint8Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::i16: {
      auto ptr = reinterpret_cast<const Int16Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::u16: {
      auto ptr = reinterpret_cast<const Uint16Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::i32: {
      auto ptr = reinterpret_cast<const Int32Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::u32: {
      auto ptr = reinterpret_cast<const Uint32Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::i64: {
      auto ptr = reinterpret_cast<const Int64Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::u64: {
      auto ptr = reinterpret_cast<const Uint64Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::f32: {
      auto ptr = reinterpret_cast<const FloatValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::f64: {
      auto ptr = reinterpret_cast<const DoubleValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::str: {
      auto ptr = reinterpret_cast<const StringValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::str_list: {
      auto ptr = reinterpret_cast<const StringList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::int32_list: {
      auto ptr = reinterpret_cast<const Int32List *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::float_list: {
      auto ptr = reinterpret_cast<const FloatList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::bin: {
      auto ptr = reinterpret_cast<const BinaryValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Value> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline const Dictionary *GetDictionary(const void *buf) {
  return flatbuffers::GetRoot<Dictionary>(buf);
}

inline const Dictionary *GetSizePrefixedDictionary(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Dictionary>(buf);
}

inline bool VerifyDictionaryBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Dictionary>(nullptr);
}

inline bool VerifySizePrefixedDictionaryBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Dictionary>(nullptr);
}

inline void FinishDictionaryBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Dictionary> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDictionaryBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Dictionary> root) {
  fbb.FinishSizePrefixed(root);
}

} // namespace schema
} // namespace mltk

#endif  // FLATBUFFERS_GENERATED_DICTIONARY_H_
