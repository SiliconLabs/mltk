from typing import List
import os
from collections import OrderedDict
import json
import functools

from prettytable import PrettyTable
from mltk.utils.string_formatting import format_units as format_units_func
from .tflite_model import (TfliteLayer, TfliteModel, TfliteOpCode)


class ProfilingLayerResult(object):
    """Profiling results for an individual layer of a model"""
    def __init__(
            self, 
            tflite_layer:TfliteLayer,
            ops:int = 0,
            macs:int = 0,
            cpu_cycles:int = 0,
            accelerator_cycles:int = 0,
            accelerator_loads:int = 0,
            accelerator_optimized_loads:int = 0,
            accelerator_parallel_loads:int = 0,
            time:float = 0.0,
            energy:float = 0.0,
            error_msg:str=None,
            **kwargs
    ):
        self._layer: TfliteLayer = tflite_layer
        self._ops:int = ops
        self._macs:int = macs
        self._cpu_cycles:int = cpu_cycles
        self._accelerator_cycles:int = accelerator_cycles
        self._accelerator_loads = accelerator_loads or 0
        self._accelerator_optimized_loads = accelerator_optimized_loads or 0
        self._accelerator_parallel_loads = accelerator_parallel_loads or 0
        self._time:float = time
        self._energy:float = energy
        self._error_msg:str = error_msg 


    @property
    def is_accelerated(self) -> bool:
        """Return true if this layer was executed on the accelerator"""
        return self._accelerator_cycles > 0
    @property
    def is_unsupported(self) -> bool:
        """Return true if this layer should have been accelerated but exceeds the limits of the accelerator"""
        return self._error_msg is not None
    @property 
    def error_msg(self) -> str:
        """Error message generated by accelerator if layer was not supported"""
        return self._error_msg
    @property
    def tflite_layer(self) -> TfliteLayer:
        """Associated TF-Lite layer"""
        return self._layer 
    @property
    def index(self) -> int:
        """Index of this layer in the model"""
        return self._layer.index
    @property
    def name(self) -> str:
        """Name of current layer as: Op<index>-<OpCodeStr>"""
        return self._layer.name 
    @property
    def opcode_str(self) -> str:
        """OpCode as a string"""
        return self._layer.opcode_str
    @property
    def opcode(self) -> TfliteOpCode:
        """OpCode"""
        return self._layer.opcode
    @property
    def macs(self) -> int:
        """Number of Multiple-Accumulate operations required by this layer"""
        return self._macs
    @property
    def ops(self) -> int:
        """Number of operations required by this layer"""
        return self._ops
    @property
    def accelerator_cycles(self) -> int:
        """Number of accelerator clock cycles required by this layer"""
        return self._accelerator_cycles
    @property
    def accelerator_loads(self) -> int:
        """The number of times the accelerator was loaded"""
        return self._accelerator_loads
    @property
    def accelerator_optimized_loads(self) -> int:
        """The number of times the accelerator was loaded with an optimized program"""
        return self._accelerator_optimized_loads
    @property
    def accelerator_parallel_loads(self) -> int:
        """The number of times the accelerator was loaded with an parallelized optimizations"""
        return self._accelerator_parallel_loads
    @property
    def cpu_cycles(self) -> int:
        """Number of CPU clock cycles required by this layer"""
        return self._cpu_cycles
    @property
    def time(self) -> float:
        """Time in seconds required by this layer"""
        return self._time
    @property
    def energy(self) -> float:
        """Energy in Joules required by this layer
        The energy is relative to the 'baseline' energy (i.e. energy used while the device was idling)
        """
        return self._energy
    @property
    def options_str(self) -> str:
        """Layer configuration options as a string"""
        return f'{self._layer.options}'
    @property
    def input_shape_str(self) -> str:
        """Layer input shape(s) as a string"""
        return ','.join([f'{x.shape}' for x in self._layer.inputs])
    @property
    def input_dtype_str(self) -> str:
        """Layer input data type(s) as a string"""
        return ','.join([x.dtype_str for x in self._layer.inputs])
    @property
    def output_shape_str(self) -> str:
        """Layer output shape(s) as a string"""
        return ','.join([f'{x.shape}' for x in self._layer.outputs])
    @property
    def output_dtype_str(self) -> str:
        """Layer output data type(s) as a string"""
        return ','.join([f'{x.dtype_str}' for x in self._layer.outputs])

    def get_summary(self, include_labels=False, format_units=False, excluded_columns:list=None) -> dict:
        """Return a summary of the layer profiling results as a dictionary"""
        excluded_columns = excluded_columns or []
        unit_formatter = functools.partial(format_units_func, add_space=False, precision=1) if format_units else lambda x: x
        summary = OrderedDict(
            index               = ('Index', self.index), 
            opcode              = ('OpCode', self.opcode_str), 
            ops                 = ('# Ops', unit_formatter(self.ops)),
            macs                = ('# MACs', unit_formatter(self.macs)),
            accelerator_cycles  = ('Acc Cycles', unit_formatter(self.accelerator_cycles)),
            cpu_cycles          = ('CPU Cycles', unit_formatter(self.cpu_cycles)), 
            energy              = ('Energy (J)', unit_formatter(self.energy)), 
            time                = ('Time (s)', unit_formatter(self.time)), 
            input_shape         = ('Input Shape', self.input_shape_str),
            output_shape        = ('Output Shape', self.output_shape_str),
            options             = ('Options', self.options_str),
            supported           = ('Supported?', not self.is_unsupported), 
            error_msg           = ('Error Msg', self.error_msg if self.error_msg or not format_units else '')
        )
        for col in excluded_columns:
            del summary[col]

        if not include_labels:
            for key, value in summary.items():
                summary[key] = value[1]
        return summary




class ProfilingModelResults(object):
    """Results from profiling model for specific accelerator"""

    def __init__(
        self,
        model:TfliteModel,
        accelerator:str=None,
        cpu_clock_rate:int = 0,
        runtime_memory_bytes:int = 0,
        layers: List[ProfilingLayerResult] = None,
        is_simulated = True,
    ):
        self._model:TfliteModel = model
        self._model_name:str = None
        self._accelerator:str = accelerator 
        self._cpu_clock_rate:int = cpu_clock_rate
        self._runtime_memory_bytes:int = runtime_memory_bytes
        self._layers: List[ProfilingLayerResult] = layers or []
        self._is_simulated = is_simulated

    @property
    def name(self) -> str:
        """Name of the profiled model"""
        return self._model_name
    @property
    def tflite_model(self) -> TfliteModel:
        """Associated TfliteModel"""
        return self._model
    @property
    def accelerator(self) -> str:
        """Name of accelerator used for profiling"""
        return self._accelerator 
    @property
    def is_simulated(self) -> bool:
        """True if the simulator was used to generate the results, else False if an embedded device was used"""
        return self._is_simulated 
    @property
    def cpu_clock_rate(self) -> int:
        """Clock rate in hertz"""
        return self._cpu_clock_rate
    @property
    def runtime_memory_bytes(self) -> int:
        """Total SRAM in bytes required by ML library
        NOTE: This only include the ML run-time memory, it does NOT
        include the memory required by the user application or external
        pre-processing libraries (e.g. DSP)
        """
        return self._runtime_memory_bytes
    @property
    def flatbuffer_size(self) -> int:
        """Total size in bytes required by ML model
        This is the size the .tflite flatbuffer file
        """
        return self._model.flatbuffer_size
    @property
    def layers(self) -> List[ProfilingLayerResult]:
        """Profiling details of each model layer"""
        return self._layers 
    @property
    def n_layers(self) -> int:
        """Number of layers in model"""
        return len(self._layers)
    @property
    def input_shape_str(self) -> str:
        """Model input shape(s) as a string"""
        return ','.join([f'{x.shape}' for x in self._model.inputs])
    @property
    def input_dtype_str(self) -> str:
        """Model input data type(s) as a string"""
        return ','.join([x.dtype_str for x in self._model.inputs])
    @property
    def output_shape_str(self) -> str:
        """Model output shape(s) as a string"""
        return ','.join([f'{x.shape}' for x in self._model.outputs])
    @property
    def output_dtype_str(self) -> str:
        """Model output data type(s) as a string"""
        return ','.join([f'{x.dtype_str}' for x in self._model.outputs])
    @property
    def ops(self) -> int:
        """The total number of ops to execute one model inference"""
        return sum([x.ops for x in self.layers])
    @property
    def macs(self) -> int:
        """The total number of multiply-accumulate operations to execute one model inference"""
        return sum([x.macs for x in self.layers])
    @property
    def accelerator_cycles(self) -> int:
        """The total number of accelerator cycles to execute one model inference"""
        return sum([x.accelerator_cycles for x in self.layers])
    @property
    def cpu_cycles(self) -> int:
        """The total number of CPU cycles to execute one model inference"""
        return sum([x.cpu_cycles for x in self.layers])
    @property
    def time(self) -> float:
        """The total time in seconds required to execute one model inference"""
        return sum([x.time for x in self.layers])
    @property
    def energy(self) -> float:
        """The total energy required to execute one model inference"""
        return sum([x.energy for x in self.layers])
    @property
    def cpu_utilization(self) -> float:
        """Percentage of the CPU used to execute the model"""
        total_time = self.time 
        used_cpu_cycles = self.cpu_cycles 
        clock_rate = self._cpu_clock_rate
        all_cycles = clock_rate*total_time
        return 0.0 if all_cycles == 0 else min(used_cpu_cycles / all_cycles, 1.0)
    @property
    def n_unsupported_layers(self) -> int: 
        """The number of layers not supported by the accelerator"""
        return len(self.unsupported_layers)
    @property
    def unsupported_layers(self) -> List[ProfilingLayerResult]:
        """Return layers not supported by accelerator"""
        return [x for x in self.layers if x.is_unsupported]

    def get_summary(
        self, 
        include_labels=False, 
        format_units=False,
        exclude_null=True,
    ) -> dict:
        """Return a summary of the profiling results as a dictionary"""
        unit_formatter = functools.partial(format_units_func, add_space=False, precision=1) if format_units else lambda x: x
        summary = OrderedDict(
            name                = ('Name', self.name), 
            accelerator         = ('Accelerator', self.accelerator or 'None'), 
            input_shape         = ('Input Shape', self.input_shape_str),
            input_dtype         = ('Input Data Type', self.input_dtype_str),
            output_shape        = ('Output Shape', self.output_shape_str),
            output_dtype        = ('Output Data Type', self.output_dtype_str), 
            tflite_size         = ('Flash, Model File Size (bytes)', unit_formatter(self.flatbuffer_size)),
            runtime_memory_size = ('RAM, Runtime Memory Size (bytes)', unit_formatter(self.runtime_memory_bytes)),
            ops                 = ('Operation Count', unit_formatter(self.ops)),
            macs                = ('Multiply-Accumulate Count', unit_formatter(self.macs)),
            n_layers            = ('Layer Count', self.n_layers),
            n_unsupported_layers= ('Unsupported Layer Count', self.n_unsupported_layers)
        )

        if self.accelerator_cycles > 0 or not exclude_null:
            summary['accelerator_cycles']   = ('Accelerator Cycle Count', unit_formatter(self.accelerator_cycles))
        if self.cpu_cycles > 0 or not exclude_null:
            summary['cpu_cycles']           = ('CPU Cycle Count', unit_formatter(self.cpu_cycles))
        if self.cpu_cycles > 0 or not exclude_null:
            formatted_percentage = self.cpu_utilization*100
            if format_units:
                formatted_percentage = f'{formatted_percentage:.1f}'
            summary['cpu_utilization']      = ('CPU Utilization (%)', formatted_percentage)
        if self.cpu_clock_rate > 0 or not exclude_null:
            summary['cpu_clock_rate']       = ('Clock Rate (hz)', unit_formatter(self.cpu_clock_rate))

        if self.time > 0 or not exclude_null:
            summary['time']                 = ('Time (s)', unit_formatter(self.time))

        if self.energy > 0 or not exclude_null:
            summary['energy']               = ('Energy (J)', unit_formatter(self.energy))

        if self.energy > 0 or not exclude_null:
            j_per_op                        = 0 if self.ops == 0 else self.energy/self.ops
            j_per_mac                       = 0 if self.macs == 0 else self.energy/self.macs
            summary['j_per_op']             = ('J/Op', unit_formatter(j_per_op))
            summary['j_per_mac']            = ('J/MAC', unit_formatter(j_per_mac))

        if self.time > 0 or not exclude_null:
            op_per_s               = 0 if self.time == 0 else self.ops/self.time
            mac_per_s              = 0 if self.time == 0 else self.macs/self.time
            inf_per_sec            = 0 if self.time == 0 else 1/self.time
            summary['op_per_s']    = ('Ops/s', unit_formatter(op_per_s))
            summary['mac_per_s']   = ('MACs/s', unit_formatter(mac_per_s))
            if format_units:
                inf_per_sec = f'{inf_per_sec:.1f}'
            summary['inf_per_sec'] = ('Inference/s', inf_per_sec)

        if not include_labels:
            for key, value in summary.items():
                summary[key] = value[1]
        return summary


    def generate_report(self, output_dir:str, format_units:bool):
        """Generate a profiling report in the given directory"""
        os.makedirs(output_dir, exist_ok=True)
        acc = self.accelerator or 'none'
        simulated = 'simulated' if self.is_simulated else 'embedded'
        base_path = f'{output_dir}/profiling_report-{acc.lower()}-{simulated}'
        txt_path = f'{base_path}.txt'
        json_path = f'{base_path}.json'
        with open(txt_path, 'w') as f:
            f.write(self.to_string(format_units=format_units))

        with open(json_path, 'w') as f:
            f.write(self.to_json(format_units=format_units))


    def to_dict(self, format_units=False, exclude_null=True) -> dict:
        """Return profiling results as dictionary

        Arguments
            format_units: Format number values to a string with associated units, e.g. 0.0234 -> 23.4m
            exclude_null: Exclude columns with all number values (e.g. don't include energy if not energy numbers were provided)
        """
        summary = self.get_summary(
            include_labels=True, 
            format_units=format_units, 
            exclude_null=exclude_null
        )
        summary_labels = {}
        for key, value in summary.items():
            summary_labels[key] = value[0]
            summary[key] = value[1]

        excluded_columns = []
        if exclude_null:
            if self.accelerator_cycles == 0:
                excluded_columns.append('accelerator_cycles')
            if self.cpu_cycles == 0:
                excluded_columns.append('cpu_cycles')
            if self.energy == 0:
                excluded_columns.append('energy')
            if self.time == 0:
                excluded_columns.append('time')
            if self.n_unsupported_layers == 0:
                excluded_columns.append('error_msg')
                excluded_columns.append('supported')

        layer_labels = {}
        for key, e in self.layers[0].get_summary(
            include_labels=True, 
            excluded_columns=excluded_columns
        ).items():
            layer_labels[key] = e[0]

        layers = []
        for layer in self.layers:
            layers.append(layer.get_summary(
                include_labels=False, 
                format_units=format_units, 
                excluded_columns=excluded_columns
            ))

        return dict(
            summary=summary,
            summary_labels=summary_labels,
            layers=layers, 
            layer_labels=layer_labels
        ) 

    def to_json(self, indent=2, format_units=False, exclude_null=True) -> str:
        """Return profiling results as JSON

        JSON Format:

        .. code-block:: text

            {
            "summary": { key/value summary of profiling },
            "summary_labels": { key/value of printable labeles for each summary field }
            "layers": [ {<model layer results>},  ... ]
            "layers_labels": { key/value of printable labeles for each layer field }
            }

        Where the "summary" member contains:

        .. code-block:: text

            "summary": {
                "name"                : "<Name of model>",
                "accelerator"         : "<Accelerator used>",
                "input_shape"         : "<Model input shapes>",
                "input_dtype"         : "<Model input data types>",
                "output_shape"        : "<Model output shapes>",
                "output_dtype"        : "<Model output data types>",
                "tflite_size"         : <.tflite file size>,
                "runtime_memory_size" : <Estimated TFLM arena size>,
                "ops"                 : <Total # operations>,
                "macs"                : <Total # multiply-accumulate ops>,
                "accelerator_cycles"  : <Total # accelerator cycles>,
                "cpu_cycles"          : <Total estimated CPU cycles>,
                "cpu_utilization"     : <Percentage of CPU required to run an inference>,
                "cpu_clock_rate"      : <CPU clock rate hz>,
                "energy"              : <Total estimated energy in Joules>,
                "time"                : <Total estimated inference time>,
                "n_layers"            : <# of layers in model>,
                "n_unsupported_layers": <# layers unsupported by accelerator>,
                "j_per_op"            : <Joules per operation>,
                "j_per_mac"           : <Joules per multiply-accumulate>,
                "op_per_s"            : <Operations per second>,
                "mac_per_s"           : <Multiply-accumulates per second>,
                "inf_per_s"           : <Inference per second>
            }

        Where the "layers" member contains:

        .. code-block:: text

            "layers": [ {
                "index"       : <layer index>,
                "opcode"      : "<kernel opcode>",
                "options"     : "<layer options>",
                "ops"         : <# operations>,
                "macs"        : <# of multiple-accumulate operations>,
                "accelerator_cycles" : <# accelerator cycles>,
                "cpu_cycles"  : <estimated CPU cycles>,
                "energy"      : <estimated energy in Joules>,
                "time"        : <estimated layer execution time>,
                "supported"   : <true/false>,
                "err_msg"     : "<error msg if not supported by accelerator>"
                }, 
                ... 
            ]

        Arguments
            indent: Amount of indentation to use in JSON formatting
            format_units: Format number values to a string with associated units, e.g. 0.0234 -> 23.4m
            exclude_null: Exclude columns with all number values (e.g. don't include energy if not energy numbers were provided)

        Returns
            JSON formated string
        """
        return json.dumps(
            self.to_dict(format_units=format_units, exclude_null=exclude_null), 
            indent=indent
        ) 

    def to_string(self, format_units=True, exclude_null=True) -> str:
        """Return the profiling results as a string
        
        Arguments
            format_units: Format number values to a string with associated units, e.g. 0.0234 -> 23.4m
            exclude_null: Exclude columns with all number values (e.g. don't include energy if not energy numbers were provided)
        """
        results = self.to_dict(format_units, exclude_null=exclude_null)
        summary = results['summary']
        summary_labels = results['summary_labels']
        layers = results['layers']
        layer_labels = results['layer_labels']

        s = 'Profiling Summary\n'
        for key in summary:
            s += f'{summary_labels[key]}: {summary[key]}\n'

        s += '\nModel Layers\n'
        x = PrettyTable(layer_labels.values())
        for layer in layers:
            x.add_row([x for x in layer.values()])

        x.align = 'l'
        s += x.get_string()

        return s

    def __str__(self):
        return self.to_string()
